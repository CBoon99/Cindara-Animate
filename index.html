<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0">
    <title>Doppleit Animate Lite v2.2</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üé®</text></svg>">
    <link rel="manifest" href="/manifest.webmanifest">
    <style>
        :root {
            --primary: #A084CA;
            --bg: #E6EFFF;
            --timeline: #2A2D4A;
            --text: #333;
        }
        [data-theme="dark"] {
            --primary: #7A5EAC;
            --bg: #2A2D4A;
            --timeline: #1A1C2A;
            --text: #EEE;
        }
        body {
            margin: 0;
            font-family: Arial;
            background: var(--bg);
            color: var(--text);
            display: grid;
            grid-template-rows: auto 1fr auto;
            height: 100vh;
        }
        canvas { 
            border: 2px solid var(--primary); 
            margin: 10px auto;
        }
        .controls { 
            padding: 10px; 
            background: var(--bg);
            gap: 5px; 
            display: flex; 
            flex-wrap: wrap;
        }
        button { 
            padding: 6px 12px; 
            background: var(--primary); 
            border: none; 
            color: white; 
            cursor: pointer;
        }
        #timeline { 
            height: 150px; 
            background: var(--timeline); 
            overflow-x: auto; 
            position: relative; 
        }
        .frame-thumb { 
            width: 100px; 
            min-width: 80px;
            flex: 0 0 auto;
            height: 100%; 
            border: 2px solid transparent; 
            position: relative; 
        }
        .active-frame { border-color: yellow !important; }
        .tool-active { background: #6F4CAC !important; }
        .sidebar { 
            position: fixed; 
            right: 0; 
            top: 0; 
            background: var(--bg); 
            padding: 10px; 
            width: 200px; 
            box-shadow: -2px 0 5px rgba(0,0,0,0.1);
            height: 100vh;
        }
        .frame-counter {
            position: absolute;
            right: 10px;
            top: 5px;
            color: yellow;
            font-size: 0.9em;
        }
        @media (max-width: 768px) {
            canvas {
                width: 95% !important;
                height: 50vh !important;
            }
            .sidebar {
                width: 150px;
                padding: 5px;
            }
        }
    </style>
</head>
<body>
    <div class="controls">
        <button id="theme" title="Toggle theme">üåì</button>
        <button id="reset" title="Reset all">üîÑ</button>
        <button id="play">‚ñ∂</button>
        <button id="prev">‚èÆ</button>
        <button id="next">‚è≠</button>
        <button id="addFrame">+ Frame</button>
        <button id="deleteFrame">- Frame</button>
        <button id="exportGif">Export GIF</button>
    </div>
    
    <canvas id="mainCanvas"></canvas>
    
    <div id="timeline">
        <div class="frame-counter" id="frameCount">Frame 1/1</div>
        <div id="frames" style="display: flex; gap: 2px;"></div>
        <div id="playhead" style="width: 2px; background: yellow; height: 100%; position: absolute; left: 0;"></div>
    </div>

    <div class="sidebar">
        <h3>Tools</h3>
        <button id="select" class="tool-active">‚ú• Select</button>
        <button id="draw">‚úé Draw</button>
        <button id="shape">‚¨¢ Shape</button>
        <input type="color" id="color">
        
        <h3>Properties</h3>
        <label><input type="checkbox" id="fill"> Fill</label>
        <label>X: <input type="number" id="posX" disabled title="Edit mode coming soon"></label>
        <label>Y: <input type="number" id="posY" disabled title="Edit mode coming soon"></label>
        <label>Size: <input type="range" id="size" min="1" max="50" value="5"></label>
    </div>

    <div style="position: fixed; bottom: 10px; left: 10px; color: var(--text); font-size: 0.9em;">
        Tip: Draw with left mouse, add frames with "+ Frame"
    </div>

    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        let currentFrame = 0;
        let frames = [[]];
        let isDrawing = false;
        let tool = 'select';
        let tempCanvas = document.createElement('canvas');
        let tempCtx = tempCanvas.getContext('2d');
        let shapeStartPos = null;
        const GIF_SCRIPT_URL = 'https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.worker.js';

        // Theme Management
        if (!localStorage.getItem('doppleit_theme') && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.body.setAttribute('data-theme', 'dark');
        }
        document.getElementById('theme').addEventListener('click', () => {
            document.body.toggleAttribute('data-theme');
            localStorage.setItem('doppleit_theme', document.body.hasAttribute('data-theme') ? 'dark' : 'light');
        });

        // Canvas Setup
        function resizeCanvas() {
            const isMobile = window.innerWidth < 768;
            const sidebarWidth = isMobile ? 0 : 220;
            const maxWidth = window.innerWidth - sidebarWidth;
            
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            tempCtx.drawImage(canvas, 0, 0);
            
            canvas.width = isMobile ? Math.min(500, maxWidth) : Math.min(maxWidth, window.innerWidth * 0.8);
            canvas.height = window.innerHeight * (isMobile ? 0.5 : 0.6);
            
            ctx.drawImage(tempCanvas, 0, 0, tempCanvas.width, tempCanvas.height, 
                        0, 0, canvas.width, canvas.height);
            tempCanvas.width = tempCanvas.height = 0;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Tools & Drawing
        document.querySelectorAll('#select, #draw, #shape').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('#select, #draw, #shape').forEach(b => 
                    b.classList.remove('tool-active'));
                btn.classList.add('tool-active');
                tool = btn.id;
                if(tool === 'select') alert('Selection tool coming soon! ‚ú®');
            });
        });

        function startDrawing(e) {
            isDrawing = true;
            if(tool === 'draw') {
                frames[currentFrame].push({
                    type: 'path',
                    points: [getMousePos(e)],
                    color: document.getElementById('color').value,
                    size: document.getElementById('size').value
                });
            } else if(tool === 'shape') {
                shapeStartPos = getMousePos(e);
            }
        }

        function draw(e) {
            if (!isDrawing) return;
            
            if(tool === 'draw') {
                const pos = getMousePos(e);
                const currentPath = frames[currentFrame][frames[currentFrame].length - 1];
                currentPath.points.push(pos);
                redraw();
            } else if(tool === 'shape') {
                redraw();
                const currentPos = getMousePos(e);
                ctx.beginPath();
                ctx.rect(shapeStartPos.x, shapeStartPos.y, 
                        currentPos.x - shapeStartPos.x, 
                        currentPos.y - shapeStartPos.y);
                ctx.strokeStyle = document.getElementById('color').value;
                ctx.lineWidth = document.getElementById('size').value;
                ctx.stroke();
            }
        }

        function stopDrawing(e) {
            if(tool === 'shape' && shapeStartPos) {
                const endPos = getMousePos(e);
                frames[currentFrame].push({
                    type: 'rect',
                    start: shapeStartPos,
                    end: endPos,
                    color: document.getElementById('color').value,
                    size: document.getElementById('size').value,
                    fill: document.getElementById('fill').checked
                });
                redraw();
            }
            isDrawing = false;
            shapeStartPos = null;
        }

        // Frame Management
        document.getElementById('prev').addEventListener('click', () => {
            if (currentFrame > 0) currentFrame--;
            redraw();
            updateTimeline();
            updateFrameCounter();
        });

        document.getElementById('next').addEventListener('click', () => {
            if (currentFrame < frames.length - 1) currentFrame++;
            redraw();
            updateTimeline();
            updateFrameCounter();
        });

        document.getElementById('reset').addEventListener('click', () => {
            if(confirm('Clear all frames?')) {
                frames = [[]];
                currentFrame = 0;
                redraw();
                updateTimeline();
                updateFrameCounter();
            }
        });

        function updateFrameCounter() {
            document.getElementById('frameCount').textContent = 
                `Frame ${currentFrame + 1}/${frames.length}`;
        }

        // Export & Rendering
        async function exportGif() {
            const gif = new GIF({ workers: 2, quality: 10, workerScript: GIF_SCRIPT_URL });
            const originalFrame = currentFrame;

            frames.forEach((_, i) => {
                redraw(i);
                gif.addFrame(ctx, { copy: true, delay: 1000/12 });
            });

            gif.on('finished', blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `doppleit-${Date.now()}.gif`;
                a.click();
                URL.revokeObjectURL(url);
                redraw(originalFrame);
            });

            gif.render();
        }

        function drawElement(element, ctxToUse = ctx) {
            if(element.type === 'path') {
                ctxToUse.beginPath();
                ctxToUse.strokeStyle = element.color;
                ctxToUse.lineWidth = element.size;
                element.points.forEach((p, i) => {
                    if(i === 0) ctxToUse.moveTo(p.x, p.y);
                    else ctxToUse.lineTo(p.x, p.y);
                });
                ctxToUse.stroke();
            } else if(element.type === 'rect') {
                ctxToUse.beginPath();
                ctxToUse.rect(element.start.x, element.start.y, 
                            element.end.x - element.start.x, 
                            element.end.y - element.start.y);
                if(element.fill) {
                    ctxToUse.fillStyle = element.color;
                    ctxToUse.fill();
                }
                ctxToUse.strokeStyle = element.color;
                ctxToUse.lineWidth = element.size;
                ctxToUse.stroke();
            }
        }

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }

        function redraw(frame = currentFrame) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if(frames[frame]) {
                frames[frame].forEach(element => drawElement(element));
            }
        }

        // Initialization
        if(!localStorage.getItem('doppleit_help')) {
            alert('Welcome to Doppleit Lite!\n\nQuick Start:\n1. Draw with brush/shape tools\n2. Add frames for animation\n3. Preview with ‚ñ∂\n4. Export GIF when ready!');
            localStorage.setItem('doppleit_help', 'true');
        }

        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw.js')
                .catch(err => console.log('SW registration failed:', err));
        }

        // Event Listeners
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);
        document.getElementById('play').addEventListener('click', togglePlay);
        document.getElementById('addFrame').addEventListener('click', addFrame);
        document.getElementById('deleteFrame').addEventListener('click', deleteFrame);
        document.getElementById('exportGif').addEventListener('click', exportGif);

        let isPlaying = false;
        let frameInterval;
        function togglePlay() {
            isPlaying = !isPlaying;
            document.getElementById('play').textContent = isPlaying ? '‚è∏' : '‚ñ∂';
            if(isPlaying) {
                frameInterval = setInterval(nextFrame, 1000/12);
            } else {
                clearInterval(frameInterval);
            }
        }

        function nextFrame() {
            currentFrame = (currentFrame < frames.length - 1) ? currentFrame + 1 : 0;
            redraw();
            updateTimeline();
            updateFrameCounter();
        }

        function addFrame() {
            frames.push([]);
            currentFrame = frames.length - 1;
            updateTimeline();
            updateFrameCounter();
        }

        function deleteFrame() {
            if(frames.length <= 1) return;
            frames.splice(currentFrame, 1);
            currentFrame = Math.min(currentFrame, frames.length - 1);
            if(frames.length < 1) frames = [[]];
            redraw();
            updateTimeline();
            updateFrameCounter();
        }

        function updateTimeline() {
            const container = document.getElementById('frames');
            container.innerHTML = '';
            
            frames.forEach((frame, i) => {
                const thumb = document.createElement('canvas');
                thumb.className = `frame-thumb ${i === currentFrame ? 'active-frame' : ''}`;
                thumb.width = 100;
                thumb.height = 100;
                
                const thumbCtx = thumb.getContext('2d');
                thumbCtx.scale(100/canvas.width, 100/canvas.height);
                frame.forEach(element => drawElement(element, thumbCtx));
                
                thumb.addEventListener('click', () => {
                    currentFrame = i;
                    redraw();
                    updateTimeline();
                    updateFrameCounter();
                });
                container.appendChild(thumb);
            });
        }

        // Initial render
        updateTimeline();
        updateFrameCounter();
    </script>
</body>
</html>